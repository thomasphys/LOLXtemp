#include "LoLXSphere.hh"
#include "globals.hh"
#include "G4SystemOfUnits.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

LoLXSphere::LoLXSphere(const G4String& name) : G4VSolid(name)
{
    G4double sqrt2 = sqrt(2.0);
    G4double pi = 3.141592653589793;
    port_h = 1.0*mm;
    port_w = 12.0*mm;
    port_r = 26.355044*mm;
    port_r2 = port_r*port_r;
    filter_h = 1.0*mm;
    filter_w = 13.5*mm;
    filter_r = port_r+port_h;
    filter_r2 = filter_r*filter_r;
    sipm_h = 4.0*mm;
    sipm_w = 15.1*mm;
    sipm_r = filter_r+filter_h;
    sipm_r2 = sipm_r*sipm_r;
    
    r_in = sqrt(2.*(port_w/2.)*(port_w/2.)+port_r*port_r);
    r_out = sqrt(2.*(sipm_w/2.)*(sipm_w/2.)+(sipm_r+sipm_h)*(sipm_r+sipm_h));
    r_filtcor
    
    r_in2 = r_in*r_in;
    r_out2 = r_out*r_out;
    
    costheta_sipm_cor = cos(atan((sqrt2*sipm_w/2.)/sipm_r));
    costheta_filter_cor = cos(atan((sqrt2*filter_w/2.)/filter_r)));
    costheta_port_cor = cos(atan((sqrt2*port_w/2.)/port_r)));
    
    costheta_sipm_edg = cos(atan((sipm_w/2.)/sipm_r));
    costheta_filter_edg = cos(atan((filter_w/2.)/filter_r)));
    costheta_port_edg = cos(atan((port_w/2.)/port_r)));
    costheta_in_edg = cos(atan((port_w/2.)/r_in)));
    
    min_costheta = costheta_sipm_cor;
    if(min_costheta > costheta_filter_cor) min_costheta = costheta_filter_cor;
    if(min_costheta > costheta_port_cor) min_costheta = costheta_port_cor;
    
    sipm_center.resize(32,G4ThreeVector(0.,0.,1.0));
    
    sipm_center[0].setTheta(pi/8.); sipm_center[0].setPhi(0.0);
    sipm_center[1].setTheta(pi/8.); sipm_center[1].setPhi(pi/2.);
    sipm_center[2].setTheta(pi/8.); sipm_center[2].setPhi(pi);
    sipm_center[3].setTheta(pi/8.); sipm_center[3].setPhi(3.*pi/2.);
  
    sipm_center[4].setTheta(pi/4.); sipm_center[4].setPhi(pi/4.);
    sipm_center[5].setTheta(pi/4.); sipm_center[5].setPhi(3.*pi/4.);
    sipm_center[6].setTheta(pi/4.); sipm_center[6].setPhi(5.*pi/4.);
    sipm_center[7].setTheta(pi/4.); sipm_center[7].setPhi(7.*pi/4.);
      
    sipm_center[8].setTheta(3.*pi/8.); sipm_center[8].setPhi(0.0);
    sipm_center[9].setTheta(3.*pi/8.); sipm_center[9].setPhi(pi/2.);
    sipm_center[10].setTheta(3.*pi/8.); sipm_center[10].setPhi(pi);
    sipm_center[11].setTheta(3.*pi/8.); sipm_center[11].setPhi(3.*pi/2.);
    
    sipm_center[12].setTheta(pi/2.); sipm_center[12].setPhi(pi/8.);
    sipm_center[13].setTheta(pi/2.); sipm_center[13].setPhi(3.*pi/8.);
    sipm_center[14].setTheta(pi/2.); sipm_center[14].setPhi(5.*pi/8.);
    sipm_center[15].setTheta(pi/2.); sipm_center[15].setPhi(7.*pi/8.);
    sipm_center[16].setTheta(pi/2.); sipm_center[16].setPhi(9.*pi/8.);
    sipm_center[17].setTheta(pi/2.); sipm_center[17].setPhi(11.*pi/8.);
    sipm_center[18].setTheta(pi/2.); sipm_center[18].setPhi(13.*pi/8.);
    sipm_center[19].setTheta(pi/2.); sipm_center[19].setPhi(15.*pi/8.);
    
    sipm_center[20].setTheta(5.*pi/8.); sipm_center[20].setPhi(0.0);
    sipm_center[21].setTheta(5.*pi/8.); sipm_center[21].setPhi(pi/2.);
    sipm_center[22].setTheta(5.*pi/8.); sipm_center[22].setPhi(pi);
    sipm_center[23].setTheta(5.*pi/8.); sipm_center[23].setPhi(3.*pi/2.);
      
    sipm_center[24].setTheta(3.*pi/4.); sipm_center[24].setPhi(pi/4.);
    sipm_center[25].setTheta(3.*pi/4.); sipm_center[25].setPhi(3.*pi/4.);
    sipm_center[26].setTheta(3.*pi/4.); sipm_center[26].setPhi(5.*pi/4.);
    sipm_center[27].setTheta(3.*pi/4.); sipm_center[27].setPhi(7.*pi/4.);
       
    sipm_center[28].setTheta(7.*pi/8.); sipm_center[28].setPhi(0.0);
    sipm_center[29].setTheta(7.*pi/8.); sipm_center[29].setPhi(pi/2.);
    sipm_center[30].setTheta(7.*pi/8.); sipm_center[30].setPhi(pi);
    sipm_center[31].setTheta(7.*pi/8.); sipm_center[31].setPhi(3.*pi/2.);
    
    n_ports = (int)sipm_center.size();
    
    for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
        sipm_x.push_back(G4ThreeVector(1./sqrt2,1./sqrt2,0.0));
        sipm_x[i_sipm].SetTheta(sipm_x[i_sipm].theta()+sipm_center[i_sipm].theta());
        sipm_x[i_sipm].SetPhi(sipm_x[i_sipm].phi()+sipm_center[i_sipm].phi());
        sipm_y.push_back(G4ThreeVector(1./sqrt2,-1./sqrt2,0.0));
        sipm_y[i_sipm].SetTheta(sipm_y[i_sipm].theta()+sipm_center[i_sipm].theta());
        sipm_y[i_sipm].SetPhi(sipm_y[i_sipm].phi()+sipm_center[i_sipm].phi());
        sipm_z.push_back(sipm_center[i_sipm]);
    }

}

EInside LoLXSphere::Inside(const G4ThreeVector& p)
{
    if(p.mag() > r_outtol || p.mag() < r_intol) return kOutside;
    
    //Check if it is close to one of the SiPM view ports
    for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
        G4double cos = sipm_center[i_sipm].dot(p);
        
        //rotate to corrdinate system of port and check if inside one of the boxes that define the port.
        if(cos > min_costheta){
            G4ThreeVector pos(p.dot(sipm_x[i_sipm]),p.dot(sipm_y[i_sipm]),p.dot(sipm_z[i_sipm]));
            pos.Rotate(pi/4.,G4ThreeVector(0.,0.,1.0));
            
            if(pos.z()<filter_rtol && pos.x() > -port_wtol/2. && pos.x() < port_wtol/2. && pos.y() > -port_wtol/2. && pos.y() < port_wtol/2.){port_wp=i_sipm; return kOutside;}
            if(pos.z()<sipm_rtol && pos.x() > -filter_wtol/2. && pos.x() < fiter_wtol/2. && pos.y() > -filter_wtol/2. && pos.y() < filter_w/2.){port_wp=i_sipm; return kOutside;}
            if(pos.z()<=r_outtol && pos.x() > -sipm_wtol/2. && pos.x() < sipm_wtol/2. && pos.y() > -sipm_wtol/2. && pos.y() < sipm_wtol/2.){port_wp=i_sipm; return kOutside;}
        }
    }

    //within radius and not in port means the point is inside volume.
    return kInside;
}

G4double LoLXSphere::DistanceToIn(const G4ThreeVector& p)
{

    //check for solution.
    return (G4double)(p.mag()-r_out);

}

G4double LoLXSphere::ComputeBoxIntercept(const G4ThreeVector& p, const G4ThreeVector& v, int box)
{
    G4ThreeVector pos(p.dot(sipm_x[port_wp]),p.dot(sipm_y[port_wp]),p.dot(sipm_z[port_wp]));
    G4ThreeVector dir(v.dot(sipm_x[port_wp]),v.dot(sipm_y[port_wp]),v.dot(sipm_z[port_wp]));
    pos.Rotate(pi/4.,G4ThreeVector(0.,0.,1.0));
    dir.Rotate(pi/4.,G4ThreeVector(0.,0.,1.0));
    
    G4double d_ym;
    G4double d_yp;
    G4double d_xm;
    G4double d_xp;
    G4double d_z;
    
    if(box==0){
        G4double d_ym = (pos.y()-(sipm_w/2.))/dir.y();
        d_yp = (pos.y()+(port_w/2.))/dir.y();
        d_xm = (pos.x()-(port_w/2.))/dir.x();
        d_xp = (pos.x()+(port_w/2.))/dir.x();
        d_z = 10000.;
    }else if(box==1){
        d_ym = (pos.y()-(filter_w/2.))/dir.y();
        d_yp = (pos.y()+(filter_w/2.))/dir.y();
        d_xm = (pos.x()-(filter_w/2.))/dir.x();
        d_xp = (pos.x()+(filter_w/2.))/dir.x();
        if(dir.z()<0.0) d_z = -(pos.z()-filter_r)/dir.z();
        else d_z = 10000.;
    }else{
        G4double d_ym = (pos.y()-(sipm_w/2.))/dir.y();
        d_yp = (pos.y()+(sipm_w/2.))/dir.y();
        d_xm = (pos.x()-(sipm_w/2.))/dir.x();
        d_xp = (pos.x()+(sipm_w/2.))/dir.x();
        if(dir.z()<0.0) d_z = -(pos.z()-sipm_r)/dir.z();
        else d_z = 10000.;
    }
            
    G4double dist;
    G4ThreeVector normbox;
    G4ThreeVector normbox_point;
            
    if(dir.x() == 0.0){
        if(d_ym > d_yp){
            dist = d_ym
            normalbox = G4ThreeVector(0.,1.0,0.0);
            normalbox_point = pos+dist*dir;
        }else{
            dist = d_yp
            normalbox = G4ThreeVector(0.,-1.0,0.0);
            normalbox_point = pos+dist*dir;
        }
                
    }else if(dir.y() == 0.0){
        if(d_xm > d_xp){
            dist = d_xm
            normalbox = G4ThreeVector(1.0,0.0,0.0);
            normalbox_point = pos+dist*dir;
        }else{
            dist = d_xp
            normalbox = G4ThreeVector(-1.0,0.0,0.0);
            normalbox_point = pos+dist*dir;
        }
                
    }else{
        G4double dispos[2];
        G4ThreeVector nor[2];
        if(d_ym > 0.0){
            dispos[0] = d_ym;
            nor[0] = G4ThreeVector(0.,1.0,0.0);
        }else{
            dispos[0] = d_yp;
            nor[0] = G4ThreeVector(0.,-1.0,0.0);
        }
        if(d_xm > 0.0){
            dispos[1] = d_xm;
            nor[1] = G4ThreeVector(1.0,0.0,0.0);
        }else{
            dispos[1] = d_xp;
            nor[1] = G4ThreeVector(-1.0,0.0,0.0);
        }
            
        if(dispos[0] < dispos[1]){
            dist = dispos[0]
            normalbox = nor[0];
            normalbox_point = pos+dist*dir;
        }else{
            dist = dispos[1]
            normalbox = nor[1];
            normalbox_point = pos+dist*dir;
        }
    }
    
    //check if you first intersect the Z normal plane.
    if(d_z<dist){
        normalbox = G4ThreeVector(0.,0.0,1.0);
        dist *= d_z;
        normalbox_point = pos+dist*dir;
    }
    
    normal = normalbox.x()*sipm_x[port_wp] + normalbox.y()*sipm_y[port_wp] + normalbox.z()*sipm_z[port_wp];
    normal_point = normalbox_point.x()*sipm_x[port_wp] + normalbox_point.y()*sipm_y[port_wp] + normalbox_point.z()*sipm_z[port_wp];

    return dist;
}


G4double LoLXSphere::TraverseDistance(const G4ThreeVector& p, const G4ThreeVector& v, const G4double additional=0.0){

        //compute intersection on inner
        double v_dot_p = v.dot(p);
        double v_dot_p2 = v_dot_p*v_dot_p;
    
        d_in = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_in2);
        G4ThreeVector int_in = p+d_in*v;
        G4ThreeVector int_in_hat = int_in;
        int_in_hat.setMag(1.0);
    
        if(Inside(d_in) == kInside) return d_in+additional;
    
        G4double d_port = -v_dot_p-sqrt(v_dot_p2-p.mag2()+port_r2);
        G4ThreeVector int_port = p+d_filt*v;
    
        if(Inside(int_port) == kInside){
            return d_in+ComputeBoxIntercept(int_out,v,2);
        }
    
        G4double d_filt = -v_dot_p-sqrt(v_dot_p2-p.mag2()+filter_r2);
        G4ThreeVector int_filt = p+d_filt*v;
    
        //intersects between outter radius and SiPM radius
        if(!(v_dot_p2-p.mag2()+filter_r2>0.0) || Inside(int_port) == kInside){
            return d_port+ComputeBoxIntercept(int_out,v,2);
        }
    
    
        G4double d_sipm = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_sipm2);
        G4ThreeVector int_sipm = p+d_in*v;
    
        if(Inside(int_sipm) == kInside){
            return d_filt+ComputeBoxIntercept(int_filt,v,2);
        }
    
        G4double d_out = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_out2);
        G4ThreeVector int_out = p+d_in*v;
        
        if(Inside(int_out) == kInside){
            return d_sipm+ComputeBoxIntercept(int_sipm,v,2);
        }
    
        return kinfinity;
}

G4double LoLXSphere::CheckLayerInteractions(const G4ThreeVector& p, const G4ThreeVector& v)
{
        //check if solution exists
        double v_dot_p = v.dot(p);
        double v_dot_p2 = v_dot_p*v_dot_p;
        if(v_dot_p2-p.mag2()+r_out*r_out2>0.0) return kInfinity;
    
        //compute intersection with outter radius.
        G4double d_out = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_out2);
        G4ThreeVector int_out = p+d_out*v;
    
        G4double d_out = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_out2);
        G4ThreeVector int_out = p+d_out*v;
    
        LoLXSphere::Inside(const G4ThreeVector& p);

}

G4double LoLXSphere::DistanceToIn(const G4ThreeVector& p, const G4ThreeVector& v)
{
        //check if solution exists
        double v_dot_p = v.dot(p);
        double v_dot_p2 = v_dot_p*v_dot_p;
        if(!(v_dot_p2-p.mag2()+r_out2>0.0)) return kInfinity;
    
        //compute intersection with outter radius.
        G4double d_out = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_out2);
        G4ThreeVector int_out = p+d_out*v;
        if(Inside(int_out) == kInside){
            normal = int_out;
            normal.setMag(1.0);
            normal_point = int_out;
            return d_out;
        }
    
        G4double d_filt = -v_dot_p-sqrt(v_dot_p2-p.mag2()+filter_r2);
        G4ThreeVector int_filt = p+d_filt*v;
    
        //intersects between outter radius and SiPM radius
        if(!(v_dot_p2-p.mag2()+filter_r2>0.0) || Inside(int_filt) == kInside){
            return d_out+ComputeBoxIntercept(int_out,v,2);
        }
    
        G4double d_port = -v_dot_p-sqrt(v_dot_p2-p.mag2()+port_r2);
        G4ThreeVector int_port = p+d_filt*v;
    
        if(!(v_dot_p2-p.mag2()+port_r2>0.0) || Inside(int_port) == kInside){
            return d_filt+ComputeBoxIntercept(int_out,v,2);
        }
    
        G4double d_in = -v_dot_p-sqrt(v_dot_p2-p.mag2()+r_in2);
        G4ThreeVector int_in = p+d_in*v;
        if(!(v_dot_p2-p.mag2()+r_in2>0.0) || Inside(int_in) == kInside){
            return d_port+ComputeBoxIntercept(int_out,v,2);
        }
    
        return TraverseDistance(int_in,v,d_in);
}

G4ThreeVector LoLXSphere::SurfaceNormal(const G4ThreeVector& p)
{
    if((normal_point-p).mag()<2.*kCarTolerance) return normal;
    
    
    if(p.mag() == r_out) return p.Unit();
    if(p.mag() == r_in) return -p.Unit();

    //Check if it is close to one of the SiPM view ports
    for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
        G4double cos = sipm_center[i_sipm].dot(p);
        
        //rotate to corrdinate system of port and check if inside one of the boxes that define the port.
        if(cos > min_costheta){
            G4ThreeVector pos(p.dot(sipm_x[i_sipm]),p.dot(sipm_y[i_sipm]),p.dot(sipm_z[i_sipm]));
            pos.Rotate(pi/4.,G4ThreeVector(0.,0.,1.0));
            
            if(pos.z() > simp_r && pos.x()<simp_wtol && pos.y()<simp_wtol){
                if(pos.x()*pos.x()>pos.y()*pos.y()){
                    if(pos.x()<0.0){
                        return sipm_x[i_sipm];
                    }else{
                        return -sipm_x[i_sipm];
                    }
                }else{
                    if(pos.y()<0.0){
                        return sipm_y[i_sipm];
                    }else{
                        return -sipm_y[i_sipm];
                    }
                }
            }else if(pos.z() == simp_r){
                return p.Unit();
            }else if(pos.z() > filter_r){
                if(pos.x()*pos.x()>pos.y()*pos.y()){
                    if(pos.x()<0.0){
                        return sipm_x[i_sipm];
                    }else{
                        return -sipm_x[i_sipm];
                    }
                }else{
                    if(pos.y()<0.0){
                        return sipm_y[i_sipm];
                    }else{
                        return -sipm_y[i_sipm];
                    }
                }
            }else if(pos.z() == filter_r){
                return p.Unit();
            }else if(pos.z() > port_r){
                if(pos.x()*pos.x()>pos.y()*pos.y()){
                    if(pos.x()<0.0){
                        return sipm_x[i_sipm];
                    }else{
                        return -sipm_x[i_sipm];
                    }
                }else{
                    if(pos.y()<0.0){
                        return sipm_y[i_sipm];
                    }else{
                        return -sipm_y[i_sipm];
                    }
                }
            }
        }
}

G4double LoLXSphere::DistanceToOut(const G4ThreeVector& p)
{
    
}

bool LoLXSphere::ComputeBoxInterceptExternal(const G4ThreeVector& p, const G4ThreeVector& v, int box, int i_sipm,G4double& dist_min);
{
    G4ThreeVector pos(p.dot(sipm_x[i_sipm]),p.dot(sipm_y[i_sipm]),p.dot(sipm_z[i_sipm]));
    G4ThreeVector dir(v.dot(sipm_x[i_sipm]),v.dot(sipm_y[i_sipm]),v.dot(sipm_z[i_sipm]));
    pos.Rotate(pi/4.,G4ThreeVector(0.,0.,1.0));
    dir.Rotate(pi/4.,G4ThreeVector(0.,0.,1.0));
    bool intersection = false;
    G4double d[6];
    
    if(box==0){
        d[0] = (pos.y()-(sipm_w/2.))/dir.y();
        d[1] = (pos.y()+(port_w/2.))/dir.y();
        d[2] = (pos.x()-(port_w/2.))/dir.x();
        d[3] = (pos.x()+(port_w/2.))/dir.x();
        d[4] = sipm_r;
        d[5] = sipm_r+sipm_h;
    }else if(box==1){
        d[0] = (pos.y()-(filter_w/2.))/dir.y();
        d[1] = (pos.y()+(filter_w/2.))/dir.y();
        d[2] = (pos.x()-(filter_w/2.))/dir.x();
        d[3] = (pos.x()+(filter_w/2.))/dir.x();
        d[4] = filter_r;
        d[5] = filter_r+filter_h;
    }else{
        d[0] = (pos.y()-(sipm_w/2.))/dir.y();
        d[1] = (pos.y()+(sipm_w/2.))/dir.y();
        d[2] = (pos.x()-(sipm_w/2.))/dir.x();
        d[3] = (pos.x()+(sipm_w/2.))/dir.x();
        d[4] = port_r;
        d[5] = port_r+port_h;
    }
            
    G4double dist[6];
    G4ThreeVector vert[6];
    if(dir.x() == 0.0){ dist[0] = kInfinity; dist[1] = kInfinity;}
    else{ dist[0] = (d[0]-pos.x())/dir.x(); dist[1] = (d[1]-pos.x())/dir.x();}
    if(dir.y() == 0.0){ dist[2] = kInfinity; dist[3] = kInfinity;}
    else{ dist[2] = (d[2]-pos.y())/dir.y(); dist[3] = (d[3]-pos.y())/dir.y();}
    if(dir.z() == 0.0){ dist[4] = kInfinity; dist[5] = kInfinity;}
    else{ dist[4] = (d[4]-pos.z())/dir.z(); dist[5] = (d[5]-pos.z())/dir.z();}
    
    for(int i=0; i<6; ++i) vert[i] = pos + dist[i]*dir;

    if(dist[0] > 0.0 && dist[0]<dist_min && vert[0].x()>=d[2] && vert[0].x()<=d[3] && vert[0].z()>=d[4] && vert[0].z()<=d[5]){
        intersection = true;
        dist_min = dist[0];
        normal = sipm_y[i_sipm];
        normal_point = p + vert[0].x()*sipm_x[i_sipm] + vert[0].y()*sipm_y[i_sipm] + vert[0].z()*sipm_z[i_sipm];
    }
    if(dist[1] > 0.0 && dist[1]<dist_min && vert[1].x()>=d[2] && vert[1].x()<=d[3] && vert[1].z()>=d[4] && vert[1].z()<=d[5]){
        intersection = true;
        dist_min = dist[1];
        normal = -1.*sipm_y[i_sipm];
        normal_point = p + vert[1].x()*sipm_x[i_sipm] + vert[1].y()*sipm_y[i_sipm] + vert[1].z()*sipm_z[i_sipm];
    }
    if(dist[2] > 0.0 && dist[2]<dist_min && vert[2].y()>=d[0] && vert[2].y()<=d[1] && vert[2].z()>=d[4] && vert[2].z()<=d[5]){
        intersection = true;
        dist_min = dist[2];
        normal = sipm_x[i_sipm];
        normal_point = p + vert[2].x()*sipm_x[i_sipm] + vert[2].y()*sipm_y[i_sipm] + vert[2].z()*sipm_z[i_sipm];
    }
    if(dist[3] > 0.0 && dist[3]<dist_min && vert[3].y()>=d[0] && vert[3].y()<=d[1] && vert[3].z()>=d[4] && vert[3].z()<=d[5]){
        intersection = true;
        dist_min = dist[0];
        normal = -1.*sipm_x[i_sipm];
        normal_point = p + vert[3].x()*sipm_x[i_sipm] + vert[3].y()*sipm_y[i_sipm] + vert[3].z()*sipm_z[i_sipm];
    }
    if(dist[4] > 0.0 && dist[4]<dist_min && vert[4].x()>=d[2] && vert[4].x()<=d[3] && vert[4].y()>=d[0] && vert[4].y()<=d[1]){
        intersection = true;
        dist_min = dist[4];
        normal = sipm_z[i_sipm];
        normal_point = p + vert[4].x()*sipm_x[i_sipm] + vert[4].y()*sipm_y[i_sipm] + vert[4].z()*sipm_z[i_sipm];
    }
    if(dist[5] > 0.0 && dist[5]<dist_min && vert[5].x()>=d[2] && vert[5].x()<=d[3] && vert[5].y()>=d[0] && vert[5].y()<=d[1]){
        intersection = true;
        dist_min = dist[5];
        normal = -1.*sipm_z[i_sipm];
        normal_point = p + vert[5].x()*sipm_x[i_sipm] + vert[5].y()*sipm_y[i_sipm] + vert[5].z()*sipm_z[i_sipm];
    }
    
    return intersection;
}

G4double LoLXSphere::DistanceToOut(const G4ThreeVector& p, const G4ThreeVector& v, const G4bool calcNorm=false, G4bool *validNorm=0, G4ThreeVector *n)
{
    
        //Compute inner or outter collision point.
        //outer
        G4double v_dot_p = v.dot(p);
        double v_dot_p2 = v_dot_p*v_dot_p;
        if(v_dot_p >= 0.0){
            //start at current position and move out in radius to next radial step and then check for box connections. do this unit intersecting with box or at outter surface.
            G4double dis;
            G4ThreeVector vertex;
            if(p.mag() < filter_r){
                bool intersection = false;
                G4double dist_min = -v_dot_p-sqrt(v_dot_p2-vertex.mag2()+filter_r2);
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            if(vertex.mag() < sipm_r){
                bool intersection = false;
                G4double dist_min = -v_dot_p-sqrt(v_dot_p2-vertex.mag2()+sipm_r2);
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            if(vertex.mag() < r_out){
                bool intersection = false;
                G4double dist_min = -v_dot_p-sqrt(v_dot_p2-vertex.mag2()+r_out2);
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            
        }else{
            //find point of closest connection and if it exists, the intersection with inner surface.
            double minr = min(sqrt(p.mag2()-v_dot_p), r_in);
            double maxd = -v_dot_p;
            G4double dis;
            G4ThreeVector vertex;
            if(p.Mag()>sipm_r){
                double dis;
                if(sipm_r<minr){
                    dis = maxd;
                }else{
                    dis = -v_dot_p-sqrt(v_dot_p2-p.mag2()+sipm_r2);
                    maxd -= dis;
                }
                bool intersection = false;
                G4double dist_min = dis;
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(p,v,2,i_sipm,dist_min)) intersection = true;
                }
                vertex = p+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            if(minr < sipm_r){
                double dis;
                if(filter_r<minr){
                    dis = maxd;
                }else{
                    dis = -v_dot_p-sqrt(v_dot_p2-p.mag2()+filter_r2);
                    maxd -= dis;
                }
                bool intersection = false;
                G4double dist_min = dis;
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,1,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            if(minr < filter_r){
                double dis;
                if(port_r<minr){
                    dis = maxd;
                }else{
                    dis = -v_dot_p-sqrt(v_dot_p2-p.mag2()+port_r2);
                    maxd -= dis;
                }
                bool intersection = false;
                G4double dist_min = dis;
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            //if no intersection with edge then go back up, same as before.
            if(vertex.mag() < filter_r){
                bool intersection = false;
                G4double dist_min = -v_dot_p-sqrt(v_dot_p2-vertex.mag2()+filter_r2);
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            if(vertex.mag() < sipm_r){
                bool intersection = false;
                G4double dist_min = -v_dot_p-sqrt(v_dot_p2-vertex.mag2()+sipm_r2);
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
            if(vertex.mag() < r_out){
                bool intersection = false;
                G4double dist_min = -v_dot_p-sqrt(v_dot_p2-vertex.mag2()+r_out2);
                for(int i_sipm=0; i_sipm<n_port; ++i_sipm){
                    if(ComputeBoxInterceptExternal(vertex,v,0,i_sipm,dist_min)) intersection = true;
                }
                vertex = vertex+dist_min*v;
                v_dot_p = v.dot(vertex);
                v_dot_p2 = v_dot_p*v_dot_p;
                if(intersection) return dist_min;
            }
        }
        return 0.0;
}

G4bool LoLXSphere::CalculateExtent(const EAxis pAxis, const G4VoxelLimits& pVoxelLimit, const G4AffineTransform& pTransform, G4double& pMin, G4double& pMax) const
{
}

G4GeometryType LoLXSphere::GetEntityType() const
{
}

std::ostream& LoLXSphere::StreamInfo(std::ostream& os) const
{
}